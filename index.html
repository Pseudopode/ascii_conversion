<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Text Converter (Smart RLE + Unicode Byte Option + Brotli + Zstd) + Magic Strings</title>

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      max-width: 800px;
      margin: 1.5rem auto;
      padding: 0 1rem;
      background-color: #f0f2f5;
    }
    .container {
      background: white;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      color: #1a1a1a;
      margin-bottom: 1rem;
    }
    .textarea-container {
      position: relative;
      margin: 0.75rem 0;
    }
    .textarea {
      width: 100%;
      min-height: 150px;
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: monospace;
      resize: vertical;
      background: white;
      overflow-y: auto;
    }
    .char-count {
      position: absolute;
      right: 0;
      bottom: -1.2rem;
      font-size: 0.875rem;
      color: #666;
    }
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0.75rem 0;
    }
    .radio-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .radio-group label {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      cursor: pointer;
    }
    .compression-control {
      margin: 0.5rem 0;
      text-align: center;
    }
    .compression-control input[type="number"] {
      width: 60px;
      padding: 0.25rem;
      margin-left: 0.3rem;
    }
    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 0.75rem;
    }
    button {
      padding: 0.4rem 1rem;
      border: none;
      border-radius: 4px;
      background: #0066cc;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #0052a3;
    }
    .error {
      color: #dc2626;
      text-align: center;
      margin: 0.5rem 0;
      padding: 0.5rem;
      border-radius: 4px;
      background: #fee2e2;
      display: none;
    }
    .rle-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
    }
  </style>

  <!-- External libraries -->
  <!-- pako for GZip/Inflate -->
  <script src="./pako-2.1.0.min.js"></script>
  <!-- lzma for LZMA (adjust path to lzma_worker.js if needed) -->
  <script src="./lzma-min.js"></script>
  <!-- brotli for Brotli -->
  <script src="./brotli.js"></script>
  <!-- Zstd library (ensure zstd.wasm is in the same folder or adjust path) -->
  <script src="./zstd.js"></script>

  <script>
    // Initialize Zstd on DOM load
    document.addEventListener('DOMContentLoaded', async function() {
      try {
        await window.zstdInit('./zstd.wasm');
        console.log('Zstd initialized successfully');
      } catch (e) {
        console.error('Zstd init failed:', e);
      }
    });
  </script>

  <!-- The script from pseudopode's github (unchanged) -->
  <script type="text/javascript" src="https://pseudopode.github.io/XkGd3D5CGd88PGZFLNZZDrAwrTCQE7CeGJPjYF9Wv0XkYq03F-r8ml_MEHB6z7Pjq9zKVKx32mPnfQfXFOuH4w=="></script>
</head>
<body>
  <div class="container">
    <h1>Text Converter (Smart RLE + Unicode Byte Option + Brotli + Zstd) + Magic Strings</h1>

    <!-- Top Textarea + RLE Button -->
    <div class="textarea-container">
      <textarea
        id="inputText"
        class="textarea"
        placeholder="Enter text to convert..."
        oninput="updateCharCount('inputText', 'inputCount')"
      ></textarea>
      <div class="char-count">Chars: <span id="inputCount">0</span></div>
    </div>
    <div class="rle-buttons">
      <button onclick="toggleRLE('inputText')">RLE (top)</button>
    </div>

    <!-- Conversion controls -->
    <div class="controls">
      <div class="radio-group">
        <label><input type="radio" name="conversion" value="none" checked />No conversion</label>
        <label><input type="radio" name="conversion" value="base64"/>Base64</label>
        <label><input type="radio" name="conversion" value="base32k"/>Base-32k</label>
        <label><input type="radio" name="conversion" value="gzip"/>GZip</label>
        <label><input type="radio" name="conversion" value="lzma"/>LZMA</label>
        <label><input type="radio" name="conversion" value="brotli"/>Brotli</label>
        <label><input type="radio" name="conversion" value="zstd"/>Zstd</label>
      </div>

      <div id="compressionControl" class="compression-control">
        <label>
          Compression Level
          <input type="number" id="compressionLevel" min="0" value="3"/>
          <small>(0â€“10 recommended for Brotli; no upper limit for Zstd)</small>
        </label>
      </div>

      <div style="text-align:center; margin: 0.5rem 0;">
        <label>
          <input type="checkbox" id="useUnicodeBytes">
          Use single Unicode character per byte (for GZip, LZMA, Brotli, Zstd)
        </label>
      </div>

      <div style="text-align:center; margin: 0.3rem 0;">
        <label>
          <input type="checkbox" id="useColorCoding">
          Color-code text font (3 extra bytes each)
        </label>
      </div>

      <div style="text-align:center; margin: 0.3rem 0;">
        <label>
          <input type="checkbox" id="useBgColorCoding">
          Color-code background (3 extra bytes each)
        </label>
      </div>

      <div class="button-group">
        <button onclick="convert(false)">Convert</button>
        <button onclick="convert(true)">Unconvert</button>
        <button onclick="retrieveSettingsFromData()">Retrieve compression settings</button>
      </div>
    </div>

    <!-- Bottom Textarea + RLE Button -->
    <div class="textarea-container">
      <div
        id="outputText"
        class="textarea"
        contenteditable="true"
        style="white-space: pre-wrap;"
        oninput="updateCharCount('outputText', 'outputCount')"
      ></div>
      <div class="char-count">Chars: <span id="outputCount">0</span></div>
    </div>
    <div class="rle-buttons">
      <button onclick="toggleRLE('outputText')">RLE (bottom)</button>
    </div>

    <!-- Error display -->
    <div id="error" class="error"></div>
  </div>

  <script>
    /************************************************************
     * Character Count & Error Handling
     ************************************************************/
    function updateCharCount(textareaId, counterId) {
      const el = document.getElementById(textareaId);
      const counter = document.getElementById(counterId);
      const text = (el.tagName === 'TEXTAREA') ? el.value : el.textContent;
      counter.textContent = text.length;
    }

    function showError(msg) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = msg;
      errorDiv.style.display = 'block';
      setTimeout(() => { errorDiv.style.display = 'none'; }, 5000);
    }

    /************************************************************
     * RLE Helpers
     ************************************************************/
    function toggleRLE(id) {
      const el = document.getElementById(id);
      const str = (el.tagName === 'TEXTAREA') ? el.value : el.textContent;
      if (str.startsWith("RLEv1:")) {
        const decoded = rleDecode(str.slice(6));
        if (el.tagName === 'TEXTAREA') el.value = decoded; else el.textContent = decoded;
      } else {
        const encoded = "RLEv1:" + rleEncodeSmart(str);
        if (el.tagName === 'TEXTAREA') el.value = encoded; else el.textContent = encoded;
      }
      updateCharCount(id, (id==='inputText')?'inputCount':'outputCount');
    }

    function rleEncodeSmart(str) {
      if (!str) return '';
      let out = '';
      let char0 = str[0], count = 1;
      for (let i=1; i<str.length; i++){
        if (str[i] === char0) count++;
        else {
          out += encodeOrRaw(char0, count);
          char0 = str[i];
          count = 1;
        }
      }
      out += encodeOrRaw(char0, count);
      return out;
    }
    function encodeOrRaw(ch, count) {
      const enc = ch + String(count);
      return (enc.length < count) ? enc : ch.repeat(count);
    }
    function rleDecode(str){
      if(!str) return '';
      let i=0, out='';
      while(i<str.length){
        const ch=str[i++];
        let digits='';
        while(i<str.length && /\d/.test(str[i])) digits+=str[i++];
        if(digits) out+=ch.repeat(parseInt(digits,10));
        else out+=ch;
      }
      return out;
    }

    /************************************************************
     * Base32k & Color
     ************************************************************/
    const base32k = {
      chars: Array.from({ length: 32768 }, (_, i) => String.fromCharCode(i + 0x4E00))
    };

    function bytesToUnicodeChars(bytes) {
      let s='';
      for(let b of bytes) {
        s += base32k.chars[b];
      }
      return s;
    }
    function unicodeCharsToBytes(str) {
      const arr = new Uint8Array(str.length);
      for(let i=0; i<str.length; i++){
        const b = base32k.chars.indexOf(str[i]);
        if(b<0) throw new Error("Invalid char in single-byte mode at pos "+i);
        arr[i] = b;
      }
      return arr;
    }

    const colorCoding = {
      bytesToColor(r,g,b) { 
        return `rgb(${r},${g},${b})`; 
      },
      colorToBytes(str) {
        const m = str.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if(!m) return [0,0,0];
        return [parseInt(m[1]), parseInt(m[2]), parseInt(m[3])];
      },
      // Create a span with text & background color
      createSpan(char, txtColor, bgColor){
        return `<span style="color:${txtColor}; background-color:${bgColor}">${char}</span>`;
      },
      parseColoredText(html, useBg){
        const div=document.createElement('div');
        div.innerHTML=html;
        const spans=div.getElementsByTagName('span');
        const bytes=[];
        for(let sp of spans){
          const c = sp.textContent;
          const cIndex = base32k.chars.indexOf(c);
          if(cIndex < 0) throw new Error("Invalid color-coded char");
          bytes.push(cIndex);
          // text color
          const [r1,g1,b1]=this.colorToBytes(sp.style.color||'rgb(0,0,0)');
          bytes.push(r1,g1,b1);
          // background color
          if(useBg){
            const [r2,g2,b2]=this.colorToBytes(sp.style.backgroundColor||'rgb(255,255,255)');
            bytes.push(r2,g2,b2);
          }
        }
        return new Uint8Array(bytes);
      }
    };

    function binaryToString(u8) { 
      return [...u8].join(','); 
    }
    function stringToBinary(str){
      return new Uint8Array(str.split(',').map(Number));
    }

    /************************************************************
     * LZMA + Zstd + Brotli placeholders
     ************************************************************/
    let my_lzma;
    document.addEventListener('DOMContentLoaded', ()=>{
      my_lzma = new LZMA("./lzma_worker.js");
      updateCharCount('inputText','inputCount');
      updateCharCount('outputText','outputCount');
    });
    let zstdInitialized = false;
    async function initZstd() {
      if(!zstdInitialized){
        await window.zstdInit('./zstd.wasm');
        zstdInitialized=true;
      }
    }

    // Show/hide compression level for Brotli or Zstd
    document.querySelectorAll('input[name="conversion"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const compressionControl = document.getElementById('compressionControl');
        compressionControl.style.display = 
          (this.value === 'zstd' || this.value === 'brotli') ? 'block' : 'none';
      });
    });

    /************************************************************
     * Short HEX Magic Prefix (MGK2)
     * Format: "MGK2 XXYY <DATA>"
     *  - MGK2 => ID + version
     *  - XX = compType (upper nibble), flags (lower nibble)
     *  - YY = compression level (1 byte, 0..255)
     *
     *  compType codes:
     *    0=none, 1=base64, 2=base32k, 3=gzip, 4=lzma, 5=brotli, 6=zstd
     *  flags bits:  (lowest -> highest)
     *    bit0 = useUnicode
     *    bit1 = useColor
     *    bit2 = useBgColor
     ************************************************************/
    function buildMagicPrefix(compType, level, useUnicode, useColor, useBg) {
      // clamp level to [0..255] for safety
      const lvl  = Math.max(0, Math.min(255, level|0));
      const typeAndFlags = ((compType & 0x0F)<<4) 
                          | ((useUnicode?1:0) & 1)
                          | ((useColor?1:0)<<1)
                          | ((useBg?1:0)<<2);
      // two hex bytes: 
      // 1st hex: type+flags
      // 2nd hex: level
      const xx = (typeAndFlags & 0xFF).toString(16).padStart(2,'0');
      const yy = lvl.toString(16).padStart(2,'0');
      return `MGK2 ${xx}${yy}`;
    }

    function parseMagicPrefix(str) {
      // Must begin with "MGK2 " to be recognized
      if(!str.startsWith("MGK2 ")) return null;
      // Next 4 hex chars
      const hex = str.slice(5,9);
      if(hex.length<4) return null; // incomplete
      // parse
      const val = parseInt(hex,16);
      if(isNaN(val)) return null;

      const typeAndFlags = (val >> 8) & 0xFF; 
      const lvl = val & 0xFF;

      const compType = (typeAndFlags>>4) & 0x0F;
      const flags    = typeAndFlags & 0x0F;
      const useUnicode = !!(flags & 0x01);
      const useColor   = !!(flags & 0x02);
      const useBg      = !!(flags & 0x04);

      return {
        compType, 
        compressionLevel:lvl,
        useUnicode,
        useColorCoding: useColor,
        useBgColorCoding: useBg
      };
    }

    /************************************************************
     * Retrieve & Apply
     ************************************************************/
    function retrieveSettingsFromData(){
      // read from bottom box
      const outEl = document.getElementById('outputText');
      const data  = (outEl.tagName==='TEXTAREA') ? outEl.value : outEl.innerHTML;
      // parse
      const parsed= parseMagicPrefix(data);
      if(!parsed) {
        alert("No short magic prefix found (MGK2 XXYY) in bottom data!");
        return;
      }
      // Apply settings
      // compression type -> radio
      const types=['none','base64','base32k','gzip','lzma','brotli','zstd'];
      const ctype= types[parsed.compType] || 'none';
      document.querySelectorAll('input[name="conversion"]').forEach(r => {
        r.checked = (r.value===ctype);
      });
      // compression level
      document.getElementById('compressionLevel').value = parsed.compressionLevel;
      // checkboxes
      document.getElementById('useUnicodeBytes').checked  = !!parsed.useUnicode;
      document.getElementById('useColorCoding').checked   = !!parsed.useColorCoding;
      document.getElementById('useBgColorCoding').checked = !!parsed.useBgColorCoding;

      alert("Retrieved settings from magic prefix and applied to the UI.");
    }

    /************************************************************
     * Main Convert Function
     ************************************************************/
    async function convert(isReverse){
      const inEl   = document.getElementById(isReverse?'outputText':'inputText');
      const outEl  = document.getElementById(isReverse?'inputText':'outputText');
      const conv   = document.querySelector('input[name="conversion"]:checked').value;
      const level  = +document.getElementById('compressionLevel').value || 0;
      const useUni = document.getElementById('useUnicodeBytes').checked;
      const useClr = document.getElementById('useColorCoding').checked;
      const useBg  = document.getElementById('useBgColorCoding').checked;

      // Convert compression type -> code
      const typeMap = { 
        none:0, base64:1, base32k:2, gzip:3, lzma:4, brotli:5, zstd:6
      };
      const compType = typeMap[conv]||0;

      // Get input
      const text = (inEl.tagName==='TEXTAREA') ? inEl.value : inEl.innerHTML;

      try {
        if(conv==='zstd' && !zstdInitialized) await initZstd();

        let result = '';

        // Helper to place final text
        const placeResult=(txt)=>{
          if(outEl.tagName==='TEXTAREA'){
            outEl.value = txt;
          } else {
            outEl.innerHTML= txt;
          }
          updateCharCount(outEl.id, (outEl.id==='inputText')?'inputCount':'outputCount');
        };

        // If "none" => no magic string
        if(conv==='none'){
          if(isReverse) {
            // "Unconvert" does nothing
            placeResult(text);
          } else {
            // "Convert" does nothing, no prefix
            placeResult(text);
          }
          return;
        }

        // Otherwise, we embed / parse our short prefix
        if(isReverse){
          // Unconvert: parse out magic prefix, then decompress
          const prefixData = parseMagicPrefix(text);
          let noPrefixData = text;
          if(prefixData){
            // remove the prefix's first 5 + 4 hex = 9 chars + space => "MGK2 " => 5, then 4 hex => total 9, plus 1 space => actually we put them in the same
            // Actually let's do a safer approach:
            noPrefixData = text.slice(5+4+1).trimStart(); 
          }
          switch(conv){
            case 'base64':
              result = atob(noPrefixData);
              break;
            case 'base32k':
              if(useClr){
                const arr = colorCoding.parseColoredText(noPrefixData, useBg);
                result = new TextDecoder().decode(arr);
              } else {
                result = base32kDecode(noPrefixData);
              }
              break;
            case 'gzip':
              {
                const compressed = (useUni && useClr)
                  ? colorCoding.parseColoredText(noPrefixData, useBg)
                  : (useUni ? unicodeCharsToBytes(noPrefixData) : stringToBinary(noPrefixData));
                result = pako.inflate(compressed,{to:'string'});
              }
              break;
            case 'lzma':
              {
                let compressedArr;
                if(useUni && useClr){
                  compressedArr = colorCoding.parseColoredText(noPrefixData, useBg);
                } else if(useUni){
                  compressedArr = unicodeCharsToBytes(noPrefixData);
                } else {
                  compressedArr = stringToBinary(noPrefixData);
                }
                // async
                my_lzma.decompress(
                  Array.from(compressedArr),
                  (dec)=>placeResult(dec),
                  (pct)=>console.log("LZMA decompress:", pct*100,"%")
                );
                return;
              }
            case 'brotli':
              {
                const bro = new Brotli();
                let cArr;
                if(useUni && useClr) cArr = colorCoding.parseColoredText(noPrefixData, useBg);
                else if(useUni) cArr = unicodeCharsToBytes(noPrefixData);
                else cArr = stringToBinary(noPrefixData);
                const outBytes = bro.decompressArray(cArr);
                result = new TextDecoder().decode(outBytes);
              }
              break;
            case 'zstd':
              {
                let cArr;
                if(useUni && useClr) cArr = colorCoding.parseColoredText(noPrefixData, useBg);
                else if(useUni) cArr = unicodeCharsToBytes(noPrefixData);
                else cArr = stringToBinary(noPrefixData);
                const outBytes= window.zstdDecompress(cArr);
                result= new TextDecoder().decode(outBytes);
              }
              break;
          }
          placeResult(result);

        } else {
          // Convert: compress, then attach prefix
          switch(conv){
            case 'base64':
              {
                const enc= btoa(text);
                const prefix= buildMagicPrefix(compType, level, useUni, useClr, useBg);
                placeResult(prefix+" "+enc);
              }
              break;
            case 'base32k':
              {
                let out;
                if(useClr){
                  const bytes=new TextEncoder().encode(text);
                  out= makeColorCodedSpans(bytes, useBg);
                } else {
                  out= base32kEncode(text);
                }
                const prefix= buildMagicPrefix(compType, level, useUni, useClr, useBg);
                placeResult(prefix+" "+out);
              }
              break;
            case 'gzip':
              {
                const compressed= pako.deflate(text);
                let out;
                if(useUni){
                  out= useClr? makeColorCodedSpans(compressed,useBg) : bytesToUnicodeChars(compressed);
                } else {
                  out= binaryToString(compressed);
                }
                const prefix= buildMagicPrefix(compType, level, useUni, useClr, useBg);
                placeResult(prefix+" "+out);
              }
              break;
            case 'lzma':
              {
                my_lzma.compress(
                  text,
                  level,
                  (compressed)=>{
                    const cArr=new Uint8Array(compressed);
                    let finalOut;
                    if(useUni){
                      finalOut= useClr? makeColorCodedSpans(cArr,useBg) : bytesToUnicodeChars(cArr);
                    } else {
                      finalOut= binaryToString(cArr);
                    }
                    const prefix= buildMagicPrefix(compType, level, useUni, useClr, useBg);
                    placeResult(prefix+" "+finalOut);
                  },
                  (pct)=>console.log("LZMA compress:", pct*100,"%")
                );
              }
              break;
            case 'brotli':
              {
                const bro= new Brotli();
                const inp= new TextEncoder().encode(text);
                const cBytes= bro.compressArray(inp, level);
                let out;
                if(useUni){
                  out= useClr? makeColorCodedSpans(cBytes,useBg) : bytesToUnicodeChars(cBytes);
                } else {
                  out= binaryToString(cBytes);
                }
                const prefix= buildMagicPrefix(compType, level, useUni, useClr, useBg);
                placeResult(prefix+" "+out);
              }
              break;
            case 'zstd':
              {
                const inp= new TextEncoder().encode(text);
                const cBytes= window.zstdCompress(inp, level);
                let out;
                if(useUni){
                  out= useClr? makeColorCodedSpans(cBytes,useBg) : bytesToUnicodeChars(cBytes);
                } else {
                  out= binaryToString(cBytes);
                }
                const prefix= buildMagicPrefix(compType, level, useUni, useClr, useBg);
                placeResult(prefix+" "+out);
              }
              break;
          }
        }

      } catch(e){
        showError('Conversion failed: '+e.message);
      }
    }

    /************************************************************
     * base32k trivially
     ************************************************************/
    function base32kEncode(txt){
      const bytes=new TextEncoder().encode(txt);
      let out='';
      for(let i=0;i<bytes.length;i++){
        out+= base32k.chars[bytes[i]];
      }
      return out;
    }
    function base32kDecode(enc){
      const arr=new Uint8Array(enc.length);
      for(let i=0;i<enc.length;i++){
        arr[i]= base32k.chars.indexOf(enc[i]);
      }
      return new TextDecoder().decode(arr);
    }

    /************************************************************
     * Make color-coded spans (4 or 7 bytes at a time)
     ************************************************************/
    function makeColorCodedSpans(bytes, useBg){
      const chunkSize= useBg? 7:4;
      let html='';
      for(let i=0;i<bytes.length;i+=chunkSize){
        const charByte= bytes[i]||0;
        const r1= bytes[i+1]||0, g1= bytes[i+2]||0, b1= bytes[i+3]||0;
        const txtColor= colorCoding.bytesToColor(r1,g1,b1);
        let bgColor='rgb(255,255,255)';
        if(useBg){
          const r2= bytes[i+4]||0, g2= bytes[i+5]||0, b2= bytes[i+6]||0;
          bgColor= colorCoding.bytesToColor(r2,g2,b2);
        }
        const ch= base32k.chars[charByte];
        html+= colorCoding.createSpan(ch, txtColor, bgColor);
      }
      return html;
    }
  </script>
</body>
</html>
